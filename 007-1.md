---
title: Paradigma funcional
layout: home
nav_order: 1
parent: Paradigmas
---

<!--Don't delete ths script-->
<script src = "https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id = "MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<!--Don't delete ths script-->

<h1>Paradigma funcional</h1>

<p align = "justify">
Watt [ISBN 0-470-85320-4] define que linguagem funcional é aquela onde a unidade báisca são as funções, normalmente unidades menores de um determinado problema. A atribuição de valores das variáveis se dá por meio destas funções e/ou combinação de funções. Aqui no Python as funções podem ser passadas como argumentos de outras funções e assim por diante. Fato que facilita bastante a programação e modelagem de arquiteturas de um <i>softwares</i>.
</p>

<p align = "justify">
Para construir funções em Python é necessário usar a sintaxe <code>def nome_funcao(args,):</code>. Além disso utilizaremos o padrão <code>snake_case</code> para declarar funções em Python. Para exemplificar o uso deste paradigma vamos construir uma função que devolve a soma de dois números.
</p>

```python
def soma_dois_numeros(x, y):
    return x + y
```

<p align = "justify">
Aqui faremos uma observação da instrução <code>return</code>. Esta instrução tem como objetivo devolver ao código principal o objeto de referência declarado na sequência da instrução. No caso deste exemplo o código devolve um objeto do tipo <i>float</i>. É válido salientar que em Python funções não precisam sempre ter retornos. Por exemplo você poderia utilizar uma função para retornar uma impressão ao longo de um processo. Vejamos um caso:
</p>

```python
# Construção da função
def aviso_codigo():
    print("eu passei por aqui")

# Chamada da função
aviso_codigo()
```

```cmd
eu passei por aqui
```

Exemplo Resolvido 1
{: .label .label-yellow }

<p align = "justify">
<i>
Construa uma função em Python que permita especificar ou não o argumento de entrada para dizer uma msg de Olá para um usuário.
</i>
</p>

```python
def saudacao(nome = "Usuário"):
    print(f"Olá, {nome}!")

saudacao()           
saudacao("Maria")    
```

```cmd
Olá, Usuário!
Olá, Maria!
```

<p align = "justify">
Podemos verificar que o Python permite que você atribua um valor padrão aos argumentos de entrada da função. Neste caso basta utilizar a sintaxe <code>nome = valorDesejado</code> na criação da função. Logo se o usuário necessitar a atribuição de um argumento específico ele será declarado na chamada do função no código principal.
</p>


<p align = "justify">
JESSY AQUI VOCÊ PODE FAZER ASSIM PARA FICAR MAIS LEGAL<br>
VOCÊ CONTA UMA PEQUENA TEORIA SOBRE O ARGS E FAZ O EXEMPLO DO KWARGS..<br>
AQUI O ESSNECIAL É VOCÊ MOSTRAR ESSA DIFERENÇA ENTRE ARGS E KWARGS E CLARO O EXEMPLO<br>
VEJA COMO FIZ ACIMA
Funções com número variável de argumentos:
Em Python, você pode criar funções que aceitam um número variável de argumentos usando *args e **kwargs.
</p>

```python
def somar_numeros(*args):
    total = 0
    for num in args:
        total += num
    return total

print(somar_numeros(1, 2, 3, 4, 5))  # Output: 15
```

<p align = "justify">
Ao trabalhar com algoritmos é importante entendermos o escopo das variáveis. O escopo determinará onde a variável pode ser empregada no algoritmo. Em suma, variáveis definidas dentro de uma função normalmente têm um escopo local, o que significa que elas só existem dentro da função em que ela foi definida. Variáveis definidas fora da função, na <code>main</code> por exemplo, têm escopo global. Vejamos o exemplo:
</p>

```python
# Variável global
globalVar = 10

def minha_funcao():
    # Acessando a variável global dentro da função
    print("Dentro da função:", globalVar)

# Chamando a função
minha_funcao()

# Acessando a variável global fora da função
print("Fora da função:", globalVar)
```

```cmd
Dentro da função: 10
Fora da função: 10
```

<p align = "justify">
Agora veremos a situação de um escopo local para uma variável qualquer que está alocada dentro de uma função.
</p>

```python
def minha_funcao():
    # Variável local
    localVar = 5
    print("Dentro da função:", localVar)

# Chamando a função
minha_funcao()

# Tentando acessar a variável local fora da função causará um erro
print("Fora da função:", localVar)
```

```cmd
Dentro da função: 5
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
/tmp/ipykernel_4869/4002507309.py in <module>
      8 
      9 # Tentando acessar a variável local fora da função causará um erro
---> 10 print("Fora da função:", localVar)

NameError: name 'localVar' is not defined
```

{: .warning }
> Quando o Python tentar acessar a variável localVar o interpretador acursará um erro informando que a variável não está definida.

Exemplo Resolvido 2
{: .label .label-yellow }

<p align = "justify">
<i>
Utilize o conceito de escopo de variável para alterar o valor de uma variável global dentro de uma função.
RESOLVE PARA NÓS ESSE EXEMPLO JESSY
</i>
</p>

```python
def saudacao(nome):
    global var ????
    print(f"Olá, {nome}!")

saudacao()           # Output: Olá, Usuário!
saudacao("Maria")    # Output: Olá, Maria!
```

```cmd
LEMBRAR COLOCAR AQUI O QUE VAI ACONTECER
```

<p align = "justify">
O Python suporta recursão, que é uma propriedade interessante para construção de algoritmos com reaproveitamento de código. O conceito básico é permitir que uma função chame a ela mesmo dentro dentro de si, porém para entendermos o conceito de recursividade precisamos nos concentrar na pilha de execução do algoritmo.
</p>

{: .warning }
> A chave do conceito de recursividade é encontrar o caso básico e assim definir o critério de parada.

<p align = "justify">
Imaginemos um caso de recursividade com uma contagem regressiva. Primeiramente vamos considerar o caso básico 
</p>

```python
def contagem_regressiva(n):
    while(n):
        print(n)
        n = n - 1
    print('Decolar!')

contagem_regressiva(5)
```

```cmd
5
4
3
2
1
Decolar!
```

<p align = "justify">
A recursividade segue o mesmo padrão de uma pilha em estrutura de dados. A lógica é do tipo LIFO (<i>Last In First Out)</i>), logo o primeiro elemento é o último a sair da pilha. Vamos ver o exemplo de uma calculadora.
</p>

```python
def calc():                             # Pilha de execução 1
    x = 1; y = 2                        # Pilha de execução 3
    impress()                           # Pilha de execução 4
    print('soma: ', x + y)              # Pilha de execução 5
    print('soma realizada')             # Pilha de execução 6
                                        # Pilha de execução 7
def impress():                          # Pilha de execução 8
    print('vou passar na soma')         # Pilha de execução 9
                                        # Pilha de execução 10
calc()                                  # Pilha de execução 11
```

<dl>
  <dt>\(t = 1\)</dt>
    <dd><code>
    __main__
    </code>
    </dd>
  <dt>\(t = 2\)</dt>
    <dd><code>
    __main__ linha 11 
    </code>
    </dd>
  <dt>\(t = 3\)</dt>
    <dd><code>
    __main__ linha 11 linha 8
    </code>
    </dd>
</dl>

{: .warning }
> O Python cria sempre uma função __main__ que sempre será a primeira a entrar na pilha de execução e em sequência as outras funções são chamadas. No caso do exemplo dado a pilha de execução irá eliminar a linha 8 e linha 11 dá pilha até voltar a __main__ e encerrar a execução.

<p align = "justify">
Depois de entender a questão da pilha temos que lembrar que para qualquer processo recursivo deverá existir sempre o caso básico e o critério de interrupção para finalização da chamada. Retomando o algoritmo de contagem regressiva.
</p>

```python
def contagem_regressiva(n):
    if n == 0:
        print('Decolar!')
    else:
        print(n)
        contagem_regressiva(n - 1)

contagem_regressiva(5)
```

```cmd
5
4
3
2
1
Decolar!
```

EU COLOQUEI O CONCEITO DE RECURSÃO AI VC COLOCA ESSE EXEMPLO DO FATORIAL COMO EXEMPLO RESOLVIDO. 

```python
def fatorial(n):
    if n == 0 or n == 1:
        return 1
    else:
        return n * fatorial(n - 1)

# Exemplo de uso
numero = 5
resultado = fatorial(numero)
print(f"O fatorial de {numero} é: {resultado}")

# O fatorial de 5 é: 120
```

<p align = "justify">
O Python tbm suporta outros tipos de funções, como por exemplo a função lambda (também conhecidas como funções anônimas) que podem ser definidas em uma única linha. São úteis para tarefas simples e rápidas. Em Python, as funções anônimas são funções sem um nome associado. Diferentemente das funções tradicionais definidas com a palavra-chave <code>def</code>, as funções anônimas são criadas usando a palavra-chave padrão <code>lambda</code>. Vejamos um exemplo de aplicação:
</p>

```python
dobro = lambda x: x * 2
print(dobro(5))  # Output: 10
```

```cmd
10
```


JESSY: COLOCAR Type hints 


JESSY: nota sobre a diferença de funções e métodos